import express from 'express';
import cors from 'cors';
import pg from 'pg';
import jwt from 'jsonwebtoken';
import { ethers } from 'ethers';
import rateLimit from 'express-rate-limit';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';

const app = express();
app.set('trust proxy', 1);
const PORT = process.env.PORT || 3007;
const JWT_SECRET = process.env.JWT_SECRET || 'xiuxian_secret_2026';
const VAULT_ADDRESS = process.env.VAULT_ADDRESS || '0xBce51d77b325C1A42d2aF8359f9744699102698e';
const ROON_RPC = process.env.ROON_RPC || 'https://rpc.roonchain.com/';
const RATE_PER_ROON = 10000; // 1 ROON = 10000 çµçŸ³
const FIRST_RECHARGE_BONUS = 2; // é¦–å……åŒå€

const pool = new pg.Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://roon_user:RoonG%40ming2026!@localhost:5432/xiuxian'
});

const provider = new ethers.JsonRpcProvider(ROON_RPC);

// VIP ç­‰çº§é…ç½®
const VIP_CONFIG = [
  { level: 0, name: 'æ™®é€š', minRecharge: 0, cultivationBoost: 1, gachaDiscount: 1, extraDrop: 0 },
  { level: 1, name: 'VIP1', minRecharge: 10, cultivationBoost: 1.1, gachaDiscount: 0.95, extraDrop: 0.05 },
  { level: 2, name: 'VIP2', minRecharge: 50, cultivationBoost: 1.2, gachaDiscount: 0.9, extraDrop: 0.1 },
  { level: 3, name: 'VIP3', minRecharge: 100, cultivationBoost: 1.5, gachaDiscount: 0.85, extraDrop: 0.15 },
  { level: 4, name: 'VIP4', minRecharge: 500, cultivationBoost: 1.8, gachaDiscount: 0.8, extraDrop: 0.2 },
  { level: 5, name: 'VIP5', minRecharge: 1000, cultivationBoost: 2.0, gachaDiscount: 0.7, extraDrop: 0.3 },
];

// ç­¾åˆ°å¥–åŠ±
const SIGN_REWARDS = [
  { day: 1, stones: 500, items: 'å¼ºåŒ–çŸ³x2' },
  { day: 2, stones: 800, items: 'æ´—ç»ƒçŸ³x2' },
  { day: 3, stones: 1000, items: 'å¼ºåŒ–çŸ³x5' },
  { day: 4, stones: 1500, items: 'æ´—ç»ƒçŸ³x5' },
  { day: 5, stones: 2000, items: 'å¼ºåŒ–çŸ³x10' },
  { day: 6, stones: 3000, items: 'æ´—ç»ƒçŸ³x10' },
  { day: 7, stones: 5000, items: 'ç¥å“ç¢ç‰‡x1' },
];

app.use(cors({ origin: '*' }));
app.use(express.json({ limit: '5mb' }));
app.use(rateLimit({ windowMs: 60000, max: 120 }));

// === è®¤è¯ä¸­é—´ä»¶ ===
function auth(req, res, next) {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) return res.status(401).json({ error: 'æœªç™»å½•' });
  try {
    req.user = jwt.verify(token, JWT_SECRET);
    next();
  } catch { return res.status(401).json({ error: 'tokenæ— æ•ˆ' }); }
}

// === é’±åŒ…ç™»å½• ===
app.post('/api/auth/login', async (req, res) => {
  try {
    const { wallet, signature, message } = req.body;
    if (!wallet || !signature || !message) return res.status(400).json({ error: 'å‚æ•°ç¼ºå¤±' });

    // éªŒè¯ç­¾å
    const recovered = ethers.verifyMessage(message, signature);
    if (recovered.toLowerCase() !== wallet.toLowerCase()) {
      return res.status(401).json({ error: 'ç­¾åéªŒè¯å¤±è´¥' });
    }

    // æŸ¥æ‰¾æˆ–åˆ›å»ºç©å®¶
    let result = await pool.query('SELECT * FROM players WHERE wallet = $1', [wallet.toLowerCase()]);
    if (result.rows.length === 0) {
      result = await pool.query(
        'INSERT INTO players (wallet) VALUES ($1) RETURNING *',
        [wallet.toLowerCase()]
      );
    }

    const player = result.rows[0];
    const token = jwt.sign({ wallet: player.wallet, id: player.id }, JWT_SECRET, { expiresIn: '7d' });

    res.json({ token, player: sanitizePlayer(player) });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === ä¿å­˜æ¸¸æˆæ•°æ® ===
app.post('/api/game/save', auth, async (req, res) => {
  try {
    const { gameData, combatPower, level, realm, spiritStones, name } = req.body;

    // æ£€æŸ¥æ˜¯å¦çªç ´äº†
    const old = await pool.query('SELECT level, realm, name FROM players WHERE wallet = $1', [req.user.wallet]);
    const oldLevel = old.rows[0]?.level || 1;
    const playerName = name || old.rows[0]?.name || 'æ— åä¿®å£«';

    await pool.query(
      `UPDATE players SET game_data = $1, combat_power = $2, level = $3, realm = $4, 
       spirit_stones = $5, name = $6, updated_at = NOW() WHERE wallet = $7`,
      [JSON.stringify(gameData), combatPower || 0, level || 1, realm || 'ç»ƒæ°”æœŸä¸€å±‚',
       spiritStones || 0, name || 'æ— åä¿®å£«', req.user.wallet]
    );

    // çªç ´å¹¿æ’­
    if (level > oldLevel && app.locals.broadcastEvent) {
      app.locals.broadcastEvent(`âš¡ ${playerName} çªç ´è‡³ ${realm}ï¼`, 'breakthrough');
    }

    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === ä¿å­˜æ¸¸æˆæ•°æ®ï¼ˆsendBeacon ç´§æ€¥å­˜æ¡£ï¼‰===
app.post('/api/game/save-beacon', async (req, res) => {
  try {
    const token = req.query.token;
    if (!token) return res.status(401).json({ error: 'æœªç™»å½•' });
    let user;
    try { user = jwt.verify(token, JWT_SECRET); } catch { return res.status(401).json({ error: 'tokenæ— æ•ˆ' }); }

    const { gameData, combatPower, level, realm, spiritStones, name } = req.body;
    const old = await pool.query('SELECT level, realm, name FROM players WHERE wallet = $1', [user.wallet]);
    const oldLevel = old.rows[0]?.level || 1;
    const playerName = name || old.rows[0]?.name || 'æ— åä¿®å£«';

    await pool.query(
      `UPDATE players SET game_data = $1, combat_power = $2, level = $3, realm = $4,
       spirit_stones = $5, name = $6, updated_at = NOW() WHERE wallet = $7`,
      [JSON.stringify(gameData), combatPower || 0, level || 1, realm || 'ç»ƒæ°”æœŸä¸€å±‚',
       spiritStones || 0, name || 'æ— åä¿®å£«', user.wallet]
    );

    if (level > oldLevel && app.locals.broadcastEvent) {
      app.locals.broadcastEvent(`âš¡ ${playerName} çªç ´è‡³ ${realm}ï¼`, 'breakthrough');
    }
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === åŠ è½½æ¸¸æˆæ•°æ® ===
app.get('/api/game/load', auth, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM players WHERE wallet = $1', [req.user.wallet]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'ç©å®¶ä¸å­˜åœ¨' });
    res.json({ player: sanitizePlayer(result.rows[0]) });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === å……å€¼ç¡®è®¤ ===
app.post('/api/recharge/confirm', auth, async (req, res) => {
  try {
    const { txHash } = req.body;
    if (!txHash) return res.status(400).json({ error: 'ç¼ºå°‘txHash' });

    // é˜²é‡æ”¾
    const existing = await pool.query('SELECT id FROM recharge_log WHERE tx_hash = $1', [txHash]);
    if (existing.rows.length > 0) return res.status(400).json({ error: 'è¯¥äº¤æ˜“å·²å¤„ç†' });

    // é“¾ä¸ŠéªŒè¯
    const tx = await provider.getTransaction(txHash);
    if (!tx) return res.status(400).json({ error: 'äº¤æ˜“ä¸å­˜åœ¨' });
    if (tx.to?.toLowerCase() !== VAULT_ADDRESS.toLowerCase()) {
      return res.status(400).json({ error: 'æ”¶æ¬¾åœ°å€ä¸åŒ¹é…' });
    }
    if (tx.from?.toLowerCase() !== req.user.wallet.toLowerCase()) {
      return res.status(400).json({ error: 'å‘é€åœ°å€ä¸åŒ¹é…' });
    }

    const receipt = await provider.getTransactionReceipt(txHash);
    if (!receipt || receipt.status !== 1) return res.status(400).json({ error: 'äº¤æ˜“æœªç¡®è®¤' });

    const amount = parseFloat(ethers.formatEther(tx.value));
    if (amount <= 0) return res.status(400).json({ error: 'é‡‘é¢æ— æ•ˆ' });

    let spiritStones = Math.floor(amount * RATE_PER_ROON);
    let bonusStones = 0;

    // é¦–å……åŒå€
    const player = await pool.query('SELECT first_recharge, total_recharge, vip_level FROM players WHERE wallet = $1', [req.user.wallet]);
    if (!player.rows[0].first_recharge) {
      bonusStones = spiritStones; // åŒå€
      spiritStones *= FIRST_RECHARGE_BONUS;
    }

    // è®¡ç®—æ–°VIPç­‰çº§
    const newTotal = parseFloat(player.rows[0].total_recharge) + amount;
    let newVipLevel = 0;
    for (let i = VIP_CONFIG.length - 1; i >= 0; i--) {
      if (newTotal >= VIP_CONFIG[i].minRecharge) { newVipLevel = VIP_CONFIG[i].level; break; }
    }

    // è®°å½•å……å€¼
    await pool.query(
      'INSERT INTO recharge_log (wallet, tx_hash, amount, spirit_stones, bonus_stones) VALUES ($1,$2,$3,$4,$5)',
      [req.user.wallet, txHash, amount, spiritStones, bonusStones]
    );

    // æ›´æ–°ç©å®¶
    await pool.query(
      `UPDATE players SET spirit_stones = spirit_stones + $1, total_recharge = total_recharge + $2,
       vip_level = $3, first_recharge = TRUE, updated_at = NOW() WHERE wallet = $4`,
      [spiritStones, amount, newVipLevel, req.user.wallet]
    );

    res.json({
      ok: true, amount, spiritStones, bonusStones,
      isFirstRecharge: !player.rows[0].first_recharge,
      vipLevel: newVipLevel,
      totalRecharge: newTotal
    });

    // å…¨æœå¹¿æ’­å……å€¼
    const pName = (await pool.query('SELECT name FROM players WHERE wallet=$1', [req.user.wallet])).rows[0]?.name || 'æ— åä¿®å£«';
    if (newVipLevel > player.rows[0].vip_level) {
      app.locals.broadcastEvent(`ğŸ‰ ${pName} æ™‹å‡ä¸º VIP${newVipLevel}ï¼`, 'vip');
    }
    if (!player.rows[0].first_recharge) {
      app.locals.broadcastEvent(`âœ¨ ${pName} å®Œæˆäº†é¦–å……ï¼Œè·å¾—åŒå€çµçŸ³ï¼`, 'recharge');
    }
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === VIP ä¿¡æ¯ ===
app.get('/api/vip/info', auth, async (req, res) => {
  try {
    const result = await pool.query('SELECT vip_level, total_recharge FROM players WHERE wallet = $1', [req.user.wallet]);
    const player = result.rows[0];
    const current = VIP_CONFIG[player.vip_level];
    const next = VIP_CONFIG[player.vip_level + 1] || null;
    res.json({
      vipLevel: player.vip_level,
      vipName: current.name,
      totalRecharge: player.total_recharge,
      benefits: current,
      nextLevel: next ? { need: next.minRecharge - parseFloat(player.total_recharge), benefits: next } : null,
      allLevels: VIP_CONFIG
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === æ¯æ—¥ç­¾åˆ° ===
app.post('/api/sign/daily', auth, async (req, res) => {
  try {
    const result = await pool.query('SELECT daily_sign_date, daily_sign_streak FROM players WHERE wallet = $1', [req.user.wallet]);
    const player = result.rows[0];
    const today = new Date().toISOString().split('T')[0];

    if (player.daily_sign_date === today) return res.status(400).json({ error: 'ä»Šå¤©å·²ç­¾åˆ°' });

    const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
    let streak = player.daily_sign_date === yesterday ? player.daily_sign_streak + 1 : 1;
    if (streak > 7) streak = 1;

    const reward = SIGN_REWARDS[(streak - 1) % 7];

    await pool.query(
      `UPDATE players SET daily_sign_date = $1, daily_sign_streak = $2, 
       spirit_stones = spirit_stones + $3, updated_at = NOW() WHERE wallet = $4`,
      [today, streak, reward.stones, req.user.wallet]
    );

    res.json({ ok: true, streak, reward });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === æ’è¡Œæ¦œ ===
app.get('/api/leaderboard/:type', async (req, res) => {
  try {
    const { type } = req.params;
    let query;
    switch (type) {
      case 'power':
        query = 'SELECT name, wallet, combat_power, level, realm, vip_level FROM players ORDER BY combat_power DESC LIMIT 50';
        break;
      case 'level':
        query = 'SELECT name, wallet, combat_power, level, realm, vip_level FROM players ORDER BY level DESC, combat_power DESC LIMIT 50';
        break;
      case 'recharge':
        query = 'SELECT name, wallet, total_recharge, vip_level FROM players ORDER BY total_recharge DESC LIMIT 50';
        break;
      default:
        return res.status(400).json({ error: 'æ— æ•ˆæ’è¡Œç±»å‹' });
    }
    const result = await pool.query(query);
    // éšè—é’±åŒ…ä¸­é—´éƒ¨åˆ†
    const data = result.rows.map((r, i) => ({
      rank: i + 1,
      ...r,
      wallet: r.wallet.slice(0, 6) + '...' + r.wallet.slice(-4)
    }));
    res.json({ type, data });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === å……å€¼è®°å½• ===
app.get('/api/recharge/history', auth, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT amount, spirit_stones, bonus_stones, created_at FROM recharge_log WHERE wallet = $1 ORDER BY created_at DESC LIMIT 20',
      [req.user.wallet]
    );
    res.json({ records: result.rows });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

function sanitizePlayer(p) {
  return {
    id: p.id, wallet: p.wallet, name: p.name, gameData: p.game_data,
    vipLevel: p.vip_level, totalRecharge: p.total_recharge,
    spiritStones: p.spirit_stones, level: p.level, realm: p.realm,
    combatPower: p.combat_power, firstRecharge: p.first_recharge,
    dailySignDate: p.daily_sign_date, dailySignStreak: p.daily_sign_streak
  };
}

// === æœˆå¡ç³»ç»Ÿ ===
const MONTHLY_CARD_PRICE = 10; // 10 ROON
const MONTHLY_CARD_DAILY = 5000; // æ¯æ—¥5000çµçŸ³
const MONTHLY_CARD_DAYS = 30;

// æŸ¥è¯¢æœˆå¡çŠ¶æ€
app.get('/api/monthly-card/status', auth, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM monthly_cards WHERE wallet = $1 AND expires_at > NOW() ORDER BY expires_at DESC LIMIT 1',
      [req.user.wallet]
    );
    if (result.rows.length === 0) {
      return res.json({ active: false });
    }
    const card = result.rows[0];
    const today = new Date().toISOString().split('T')[0];
    const claimed = card.last_claim_date === today;
    res.json({
      active: true,
      expiresAt: card.expires_at,
      daysClaimed: card.days_claimed,
      claimedToday: claimed,
      dailyReward: MONTHLY_CARD_DAILY,
      perks: {
        cultivationBoost: 1.2, // ä¿®ç‚¼åŠ é€Ÿ20%
        freeGacha: 1, // æ¯æ—¥å…è´¹æŠ½å¡1æ¬¡
      }
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// è´­ä¹°æœˆå¡ï¼ˆé“¾ä¸ŠéªŒè¯ï¼‰
app.post('/api/monthly-card/buy', auth, async (req, res) => {
  try {
    const { txHash } = req.body;
    if (!txHash) return res.status(400).json({ error: 'ç¼ºå°‘txHash' });

    // é˜²é‡æ”¾
    const existing = await pool.query('SELECT id FROM recharge_log WHERE tx_hash = $1', [txHash]);
    if (existing.rows.length > 0) return res.status(400).json({ error: 'è¯¥äº¤æ˜“å·²å¤„ç†' });

    // é“¾ä¸ŠéªŒè¯
    const tx = await provider.getTransaction(txHash);
    if (!tx) return res.status(400).json({ error: 'äº¤æ˜“ä¸å­˜åœ¨' });
    if (tx.to?.toLowerCase() !== VAULT_ADDRESS.toLowerCase()) return res.status(400).json({ error: 'æ”¶æ¬¾åœ°å€ä¸åŒ¹é…' });
    if (tx.from?.toLowerCase() !== req.user.wallet.toLowerCase()) return res.status(400).json({ error: 'å‘é€åœ°å€ä¸åŒ¹é…' });

    const receipt = await provider.getTransactionReceipt(txHash);
    if (!receipt || receipt.status !== 1) return res.status(400).json({ error: 'äº¤æ˜“æœªç¡®è®¤' });

    const amount = parseFloat(ethers.formatEther(tx.value));
    if (amount < MONTHLY_CARD_PRICE) return res.status(400).json({ error: `éœ€è¦ ${MONTHLY_CARD_PRICE} ROON` });

    // è®°å½•å……å€¼
    await pool.query(
      'INSERT INTO recharge_log (wallet, tx_hash, amount, spirit_stones, bonus_stones) VALUES ($1,$2,$3,0,0)',
      [req.user.wallet, txHash, amount]
    );

    // åˆ›å»º/ç»­æœŸæœˆå¡
    const current = await pool.query(
      'SELECT expires_at FROM monthly_cards WHERE wallet = $1 AND expires_at > NOW() ORDER BY expires_at DESC LIMIT 1',
      [req.user.wallet]
    );
    let expiresAt;
    if (current.rows.length > 0) {
      // ç»­æœŸï¼šåœ¨ç°æœ‰åˆ°æœŸæ—¶é—´ä¸ŠåŠ 30å¤©
      expiresAt = new Date(new Date(current.rows[0].expires_at).getTime() + MONTHLY_CARD_DAYS * 86400000);
    } else {
      expiresAt = new Date(Date.now() + MONTHLY_CARD_DAYS * 86400000);
    }

    await pool.query(
      'INSERT INTO monthly_cards (wallet, expires_at) VALUES ($1, $2)',
      [req.user.wallet, expiresAt]
    );

    // æ›´æ–°å……å€¼æ€»é¢å’ŒVIP
    const player = await pool.query('SELECT total_recharge FROM players WHERE wallet = $1', [req.user.wallet]);
    const newTotal = parseFloat(player.rows[0].total_recharge) + amount;
    let newVipLevel = 0;
    for (let i = VIP_CONFIG.length - 1; i >= 0; i--) {
      if (newTotal >= VIP_CONFIG[i].minRecharge) { newVipLevel = VIP_CONFIG[i].level; break; }
    }
    await pool.query(
      'UPDATE players SET total_recharge = total_recharge + $1, vip_level = $2 WHERE wallet = $3',
      [amount, newVipLevel, req.user.wallet]
    );

    // å…¨æœå¹¿æ’­
    const pName = (await pool.query('SELECT name FROM players WHERE wallet=$1', [req.user.wallet])).rows[0]?.name || 'æ— åä¿®å£«';
    if (app.locals.broadcastEvent) {
      app.locals.broadcastEvent(`ğŸ’³ ${pName} å¼€é€šäº†æœˆå¡ï¼`, 'monthlycard');
    }

    res.json({ ok: true, expiresAt, dailyReward: MONTHLY_CARD_DAILY });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// é¢†å–æœˆå¡æ¯æ—¥çµçŸ³
app.post('/api/monthly-card/claim', auth, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM monthly_cards WHERE wallet = $1 AND expires_at > NOW() ORDER BY expires_at DESC LIMIT 1',
      [req.user.wallet]
    );
    if (result.rows.length === 0) return res.status(400).json({ error: 'æœªå¼€é€šæœˆå¡' });

    const card = result.rows[0];
    const today = new Date().toISOString().split('T')[0];
    if (card.last_claim_date === today) return res.status(400).json({ error: 'ä»Šæ—¥å·²é¢†å–' });

    await pool.query(
      'UPDATE monthly_cards SET last_claim_date = $1, days_claimed = days_claimed + 1 WHERE id = $2',
      [today, card.id]
    );

    await pool.query(
      'UPDATE players SET spirit_stones = spirit_stones + $1 WHERE wallet = $2',
      [MONTHLY_CARD_DAILY, req.user.wallet]
    );

    res.json({ ok: true, stones: MONTHLY_CARD_DAILY, daysClaimed: card.days_claimed + 1 });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === é™æ—¶æ´»åŠ¨ ===
app.get('/api/events/active', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, name, type, description, config, rewards, starts_at, ends_at FROM events WHERE active = TRUE AND starts_at <= NOW() AND ends_at > NOW() ORDER BY created_at DESC'
    );
    res.json({ events: result.rows });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// æ´»åŠ¨æ•ˆæœæ±‡æ€»ï¼ˆå‰ç«¯ä¿®ç‚¼/æŠ½å¡æ—¶è°ƒç”¨ï¼‰
app.get('/api/events/effects', async (req, res) => {
  try {
    const result = await pool.query(
      "SELECT type, config FROM events WHERE active = TRUE AND starts_at <= NOW() AND ends_at > NOW()"
    );
    const effects = { cultivationMultiplier: 1, gachaRateBoost: 1, dropMultiplier: 1, shopDiscount: 1 };
    for (const evt of result.rows) {
      const cfg = evt.config || {};
      if (evt.type === 'double_cultivation') effects.cultivationMultiplier *= (cfg.multiplier || 2);
      if (evt.type === 'gacha_rate_up') effects.gachaRateBoost *= (cfg.rateBoost || 1.5);
      if (evt.type === 'double_drop') effects.dropMultiplier *= (cfg.multiplier || 2);
      if (evt.type === 'discount') effects.shopDiscount *= (cfg.discount || 0.8);
    }
    res.json({ effects });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// é¢†å–æ´»åŠ¨å¥–åŠ±ï¼ˆç™»å½•å¥–åŠ±ç­‰ï¼‰
app.post('/api/events/:id/claim', auth, async (req, res) => {
  try {
    const eventId = parseInt(req.params.id);
    const wallet = req.user.wallet.toLowerCase();
    // æ£€æŸ¥æ´»åŠ¨æ˜¯å¦æœ‰æ•ˆ
    const evt = await pool.query(
      'SELECT * FROM events WHERE id = $1 AND active = TRUE AND starts_at <= NOW() AND ends_at > NOW()', [eventId]
    );
    if (evt.rows.length === 0) return res.status(404).json({ error: 'æ´»åŠ¨ä¸å­˜åœ¨æˆ–å·²ç»“æŸ' });
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–
    const claimed = await pool.query(
      'SELECT id FROM event_claims WHERE event_id = $1 AND wallet = $2', [eventId, wallet]
    );
    if (claimed.rows.length > 0) return res.status(400).json({ error: 'å·²é¢†å–è¿‡è¯¥æ´»åŠ¨å¥–åŠ±' });
    // è®¡ç®—å¥–åŠ±
    const config = evt.rows[0].config || {};
    let stonesReward = 0;
    if (evt.rows[0].type === 'login_bonus') {
      stonesReward = config.dailyStones || 2000;
    }
    // è®°å½•é¢†å–
    await pool.query('INSERT INTO event_claims (event_id, wallet) VALUES ($1, $2)', [eventId, wallet]);
    // å‘æ”¾çµçŸ³
    if (stonesReward > 0) {
      await pool.query('UPDATE players SET spirit_stones = spirit_stones + $1 WHERE wallet = $2', [stonesReward, wallet]);
    }
    res.json({ ok: true, stones: stonesReward });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === PK å†å²è®°å½• ===
app.get('/api/pk/history', auth, async (req, res) => {
  try {
    const wallet = req.user.wallet.toLowerCase();
    const result = await pool.query(
      `SELECT id, name_a, name_b, winner, winner_wallet, reward, created_at,
        wallet_a, wallet_b
       FROM pk_records WHERE wallet_a = $1 OR wallet_b = $1
       ORDER BY created_at DESC LIMIT 50`, [wallet]
    );
    const records = result.rows.map(r => ({
      ...r,
      isMe: r.winner_wallet === wallet ? 'win' : r.winner === 'draw' ? 'draw' : 'lose',
      opponent: r.wallet_a === wallet ? r.name_b : r.name_a
    }));
    res.json({ records });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// PK æˆ˜ç»©ç»Ÿè®¡
app.get('/api/pk/stats', auth, async (req, res) => {
  try {
    const wallet = req.user.wallet.toLowerCase();
    const total = await pool.query('SELECT COUNT(*) FROM pk_records WHERE wallet_a = $1 OR wallet_b = $1', [wallet]);
    const wins = await pool.query('SELECT COUNT(*) FROM pk_records WHERE winner_wallet = $1', [wallet]);
    const totalReward = await pool.query('SELECT COALESCE(SUM(reward), 0) as total FROM pk_records WHERE winner_wallet = $1', [wallet]);
    res.json({
      total: parseInt(total.rows[0].count),
      wins: parseInt(wins.rows[0].count),
      losses: parseInt(total.rows[0].count) - parseInt(wins.rows[0].count),
      totalReward: parseInt(totalReward.rows[0].total)
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// === å…¬å‘Šç³»ç»Ÿ ===
app.get('/api/announcements', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, content, type FROM announcements WHERE active = TRUE ORDER BY sort_order ASC, created_at DESC LIMIT 20'
    );
    res.json({ announcements: result.rows });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});


// === å®—é—¨ç³»ç»Ÿ ===
const SECT_LEVEL_EXP = [0, 1000, 3000, 8000, 20000, 50000, 100000, 200000, 500000, 1000000];
const SECT_TASK_POOL = {
  daily: [
    { title: 'çµæ°”é‡‡é›†', description: 'é‡‡é›†å¤©åœ°çµæ°”ï¼Œä¸ºå®—é—¨ç§¯è“„åŠ›é‡', reward_contribution: 10, reward_stones: 200 },
    { title: 'å·¡å±±æŠ¤æ³•', description: 'å·¡è§†å®—é—¨å±±é—¨ï¼Œé©±é€å¦–å…½', reward_contribution: 15, reward_stones: 300 },
    { title: 'é˜µæ³•ç»´æŠ¤', description: 'ç»´æŠ¤å®—é—¨æŠ¤å±±å¤§é˜µ', reward_contribution: 12, reward_stones: 250 },
    { title: 'ä¸¹è¯ç‚¼åˆ¶', description: 'ä¸ºå®—é—¨ç‚¼åˆ¶åŸºç¡€ä¸¹è¯', reward_contribution: 20, reward_stones: 400 },
    { title: 'å¼Ÿå­æŒ‡å¯¼', description: 'æŒ‡å¯¼æ–°å…¥é—¨å¼Ÿå­ä¿®ç‚¼', reward_contribution: 8, reward_stones: 150 },
    { title: 'çµç”°è€•ç§', description: 'æ‰“ç†å®—é—¨çµç”°', reward_contribution: 10, reward_stones: 200 },
  ],
  weekly: [
    { title: 'ç§˜å¢ƒæ¢ç´¢', description: 'æ¢ç´¢å®—é—¨ç§˜å¢ƒï¼Œå¯»æ‰¾çç¨€èµ„æº', reward_contribution: 50, reward_stones: 1500 },
    { title: 'å®—é—¨å¤§æ¯”', description: 'å‚åŠ å®—é—¨å†…éƒ¨åˆ‡ç£‹å¤§æ¯”', reward_contribution: 80, reward_stones: 2000 },
    { title: 'å¦–å…½è®¨ä¼', description: 'è®¨ä¼å¨èƒå®—é—¨çš„å¼ºå¤§å¦–å…½', reward_contribution: 60, reward_stones: 1800 },
    { title: 'èµ„æºè¿é€', description: 'æŠ¤é€çè´µèµ„æºå›å®—é—¨', reward_contribution: 70, reward_stones: 2500 },
  ]
};

function randomTasks(pool, count) {
  const shuffled = [...pool].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

async function ensureSectTasks(sectId) {
  const now = new Date();
  const todayStart = new Date(now); todayStart.setHours(0,0,0,0);
  const weekStart = new Date(now); weekStart.setDate(weekStart.getDate() - weekStart.getDay()); weekStart.setHours(0,0,0,0);

  // Check daily tasks
  const dailyCheck = await pool.query(
    `SELECT id FROM sect_tasks WHERE sect_id=$1 AND type='daily' AND reset_at >= $2`, [sectId, todayStart]
  );
  if (dailyCheck.rows.length === 0) {
    await pool.query(`DELETE FROM sect_tasks WHERE sect_id=$1 AND type='daily'`, [sectId]);
    const dailies = randomTasks(SECT_TASK_POOL.daily, 3);
    for (const t of dailies) {
      await pool.query(
        `INSERT INTO sect_tasks (sect_id, type, title, description, reward_contribution, reward_stones, reset_at) VALUES ($1,'daily',$2,$3,$4,$5,$6)`,
        [sectId, t.title, t.description, t.reward_contribution, t.reward_stones, now]
      );
    }
  }

  // Check weekly tasks
  const weeklyCheck = await pool.query(
    `SELECT id FROM sect_tasks WHERE sect_id=$1 AND type='weekly' AND reset_at >= $2`, [sectId, weekStart]
  );
  if (weeklyCheck.rows.length === 0) {
    await pool.query(`DELETE FROM sect_tasks WHERE sect_id=$1 AND type='weekly'`, [sectId]);
    const weeklies = randomTasks(SECT_TASK_POOL.weekly, 1);
    for (const t of weeklies) {
      await pool.query(
        `INSERT INTO sect_tasks (sect_id, type, title, description, reward_contribution, reward_stones, reset_at) VALUES ($1,'weekly',$2,$3,$4,$5,$6)`,
        [sectId, t.title, t.description, t.reward_contribution, t.reward_stones, now]
      );
    }
  }
}

async function checkSectLevelUp(sectId) {
  const sect = await pool.query('SELECT level, exp FROM sects WHERE id=$1', [sectId]);
  if (!sect.rows.length) return;
  let { level, exp } = sect.rows[0];
  while (level < 10 && exp >= SECT_LEVEL_EXP[level]) {
    level++;
    await pool.query('UPDATE sects SET level=$1, max_members=$2 WHERE id=$3', [level, 20 + (level-1)*5, sectId]);
  }
}

// POST /api/sect/create
app.post('/api/sect/create', auth, async (req, res) => {
  try {
    const { name, description } = req.body;
    if (!name || name.length < 2 || name.length > 20) return res.status(400).json({ error: 'å®—é—¨åç§°2-20å­—' });
    const existing = await pool.query('SELECT id FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (existing.rows.length > 0) return res.status(400).json({ error: 'ä½ å·²åŠ å…¥å®—é—¨' });
    const player = await pool.query('SELECT spirit_stones, game_data FROM players WHERE wallet=$1', [req.user.wallet]);
    if (!player.rows.length) return res.status(400).json({ error: 'ç©å®¶ä¸å­˜åœ¨' });
    const gameData = typeof player.rows[0].game_data === 'string' ? JSON.parse(player.rows[0].game_data) : player.rows[0].game_data;
    const stones = gameData?.spiritStones ?? player.rows[0].spirit_stones ?? 0;
    if (stones < 50000) return res.status(400).json({ error: 'çµçŸ³ä¸è¶³ï¼Œéœ€è¦50000çµçŸ³' });
    // Deduct stones
    gameData.spiritStones = (gameData.spiritStones || 0) - 50000;
    await pool.query('UPDATE players SET game_data=$1, spirit_stones=$2 WHERE wallet=$3',
      [JSON.stringify(gameData), gameData.spiritStones, req.user.wallet]);
    const sect = await pool.query(
      'INSERT INTO sects (name, description, leader_wallet) VALUES ($1,$2,$3) RETURNING *',
      [name, description || '', req.user.wallet]
    );
    await pool.query(
      'INSERT INTO sect_members (sect_id, wallet, role) VALUES ($1,$2,$3)',
      [sect.rows[0].id, req.user.wallet, 'leader']
    );
    res.json({ ok: true, sect: sect.rows[0] });
  } catch (e) {
    if (e.code === '23505') return res.status(400).json({ error: 'å®—é—¨åç§°å·²å­˜åœ¨' });
    res.status(500).json({ error: e.message });
  }
});

// GET /api/sect/my
app.get('/api/sect/my', auth, async (req, res) => {
  try {
    const mem = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!mem.rows.length) return res.json({ sect: null });
    const sect = await pool.query('SELECT * FROM sects WHERE id=$1', [mem.rows[0].sect_id]);
    const members = await pool.query(
      `SELECT sm.wallet, sm.role, sm.contribution, sm.joined_at, p.name, p.level, p.realm, p.combat_power
       FROM sect_members sm LEFT JOIN players p ON sm.wallet = p.wallet WHERE sm.sect_id=$1 ORDER BY sm.role='leader' DESC, sm.role='elder' DESC, sm.contribution DESC`,
      [mem.rows[0].sect_id]
    );
    res.json({ sect: sect.rows[0], myRole: mem.rows[0].role, myContribution: mem.rows[0].contribution, members: members.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/sect/list
app.get('/api/sect/list', auth, async (req, res) => {
  try {
    const { search, sort } = req.query;
    let q = `SELECT s.*, COUNT(sm.id) as member_count FROM sects s LEFT JOIN sect_members sm ON s.id=sm.sect_id`;
    const params = [];
    if (search) { q += ` WHERE s.name ILIKE $1`; params.push(`%${search}%`); }
    q += ` GROUP BY s.id`;
    if (sort === 'level') q += ` ORDER BY s.level DESC, s.exp DESC`;
    else if (sort === 'members') q += ` ORDER BY member_count DESC`;
    else q += ` ORDER BY s.created_at DESC`;
    const result = await pool.query(q, params);
    res.json({ sects: result.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/join
app.post('/api/sect/join', auth, async (req, res) => {
  try {
    const { sectId } = req.body;
    const existing = await pool.query('SELECT id FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (existing.rows.length > 0) return res.status(400).json({ error: 'ä½ å·²åŠ å…¥å®—é—¨' });
    const sect = await pool.query('SELECT * FROM sects WHERE id=$1', [sectId]);
    if (!sect.rows.length) return res.status(400).json({ error: 'å®—é—¨ä¸å­˜åœ¨' });
    const count = await pool.query('SELECT COUNT(*) FROM sect_members WHERE sect_id=$1', [sectId]);
    if (parseInt(count.rows[0].count) >= sect.rows[0].max_members) return res.status(400).json({ error: 'å®—é—¨å·²æ»¡' });
    await pool.query('INSERT INTO sect_members (sect_id, wallet, role) VALUES ($1,$2,$3)', [sectId, req.user.wallet, 'member']);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/leave
app.post('/api/sect/leave', auth, async (req, res) => {
  try {
    const mem = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!mem.rows.length) return res.status(400).json({ error: 'ä½ æœªåŠ å…¥å®—é—¨' });
    if (mem.rows[0].role === 'leader') return res.status(400).json({ error: 'æŒé—¨ä¸èƒ½é€€å‡ºï¼Œè¯·å…ˆè½¬è®©æŒé—¨' });
    await pool.query('DELETE FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/kick
app.post('/api/sect/kick', auth, async (req, res) => {
  try {
    const { wallet } = req.body;
    const me = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!me.rows.length || (me.rows[0].role !== 'leader' && me.rows[0].role !== 'elder')) return res.status(403).json({ error: 'æƒé™ä¸è¶³' });
    const target = await pool.query('SELECT * FROM sect_members WHERE wallet=$1 AND sect_id=$2', [wallet, me.rows[0].sect_id]);
    if (!target.rows.length) return res.status(400).json({ error: 'è¯¥ç©å®¶ä¸åœ¨å®—é—¨ä¸­' });
    if (target.rows[0].role === 'leader') return res.status(400).json({ error: 'ä¸èƒ½è¸¢æŒé—¨' });
    if (me.rows[0].role === 'elder' && target.rows[0].role === 'elder') return res.status(400).json({ error: 'é•¿è€ä¸èƒ½è¸¢é•¿è€' });
    await pool.query('DELETE FROM sect_members WHERE wallet=$1', [wallet]);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/promote
app.post('/api/sect/promote', auth, async (req, res) => {
  try {
    const { wallet } = req.body;
    const me = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!me.rows.length || me.rows[0].role !== 'leader') return res.status(403).json({ error: 'åªæœ‰æŒé—¨å¯ä»¥å‡èŒ' });
    const target = await pool.query('SELECT * FROM sect_members WHERE wallet=$1 AND sect_id=$2', [wallet, me.rows[0].sect_id]);
    if (!target.rows.length) return res.status(400).json({ error: 'è¯¥ç©å®¶ä¸åœ¨å®—é—¨ä¸­' });
    if (target.rows[0].role === 'leader') return res.status(400).json({ error: 'å·²æ˜¯æŒé—¨' });
    if (target.rows[0].role === 'elder') return res.status(400).json({ error: 'å·²æ˜¯é•¿è€' });
    await pool.query('UPDATE sect_members SET role=$1 WHERE wallet=$2', ['elder', wallet]);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/demote
app.post('/api/sect/demote', auth, async (req, res) => {
  try {
    const { wallet } = req.body;
    const me = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!me.rows.length || me.rows[0].role !== 'leader') return res.status(403).json({ error: 'åªæœ‰æŒé—¨å¯ä»¥é™èŒ' });
    const target = await pool.query('SELECT * FROM sect_members WHERE wallet=$1 AND sect_id=$2', [wallet, me.rows[0].sect_id]);
    if (!target.rows.length) return res.status(400).json({ error: 'è¯¥ç©å®¶ä¸åœ¨å®—é—¨ä¸­' });
    if (target.rows[0].role !== 'elder') return res.status(400).json({ error: 'åªèƒ½é™èŒé•¿è€' });
    await pool.query('UPDATE sect_members SET role=$1 WHERE wallet=$2', ['member', wallet]);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/announcement
app.post('/api/sect/announcement', auth, async (req, res) => {
  try {
    const { announcement } = req.body;
    if (!announcement || announcement.length > 200) return res.status(400).json({ error: 'å…¬å‘Šä¸èƒ½ä¸ºç©ºä¸”ä¸è¶…è¿‡200å­—' });
    const me = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!me.rows.length || (me.rows[0].role !== 'leader' && me.rows[0].role !== 'elder')) return res.status(403).json({ error: 'æƒé™ä¸è¶³' });
    await pool.query('UPDATE sects SET announcement=$1 WHERE id=$2', [announcement, me.rows[0].sect_id]);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/sect/tasks
app.get('/api/sect/tasks', auth, async (req, res) => {
  try {
    const mem = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!mem.rows.length) return res.status(400).json({ error: 'ä½ æœªåŠ å…¥å®—é—¨' });
    await ensureSectTasks(mem.rows[0].sect_id);
    const tasks = await pool.query('SELECT * FROM sect_tasks WHERE sect_id=$1 ORDER BY type, id', [mem.rows[0].sect_id]);
    res.json({ tasks: tasks.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/tasks/:id/complete
app.post('/api/sect/tasks/:id/complete', auth, async (req, res) => {
  try {
    const taskId = req.params.id;
    const mem = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!mem.rows.length) return res.status(400).json({ error: 'ä½ æœªåŠ å…¥å®—é—¨' });
    const task = await pool.query('SELECT * FROM sect_tasks WHERE id=$1 AND sect_id=$2', [taskId, mem.rows[0].sect_id]);
    if (!task.rows.length) return res.status(400).json({ error: 'ä»»åŠ¡ä¸å­˜åœ¨' });
    const completedBy = task.rows[0].completed_by || [];
    if (completedBy.includes(req.user.wallet)) return res.status(400).json({ error: 'ä½ å·²å®Œæˆè¯¥ä»»åŠ¡' });
    completedBy.push(req.user.wallet);
    await pool.query('UPDATE sect_tasks SET completed_by=$1 WHERE id=$2', [JSON.stringify(completedBy), taskId]);
    // Add contribution
    await pool.query('UPDATE sect_members SET contribution=contribution+$1 WHERE wallet=$2', [task.rows[0].reward_contribution, req.user.wallet]);
    // Add stones to player
    const player = await pool.query('SELECT game_data FROM players WHERE wallet=$1', [req.user.wallet]);
    const gameData = typeof player.rows[0].game_data === 'string' ? JSON.parse(player.rows[0].game_data) : player.rows[0].game_data;
    gameData.spiritStones = (gameData.spiritStones || 0) + task.rows[0].reward_stones;
    await pool.query('UPDATE players SET game_data=$1, spirit_stones=$2 WHERE wallet=$3',
      [JSON.stringify(gameData), gameData.spiritStones, req.user.wallet]);
    res.json({ ok: true, reward_contribution: task.rows[0].reward_contribution, reward_stones: task.rows[0].reward_stones });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/sect/donate
app.post('/api/sect/donate', auth, async (req, res) => {
  try {
    const { amount } = req.body;
    if (!amount || amount < 100) return res.status(400).json({ error: 'æœ€å°‘æçŒ®100çµçŸ³' });
    const mem = await pool.query('SELECT * FROM sect_members WHERE wallet=$1', [req.user.wallet]);
    if (!mem.rows.length) return res.status(400).json({ error: 'ä½ æœªåŠ å…¥å®—é—¨' });
    const player = await pool.query('SELECT game_data FROM players WHERE wallet=$1', [req.user.wallet]);
    const gameData = typeof player.rows[0].game_data === 'string' ? JSON.parse(player.rows[0].game_data) : player.rows[0].game_data;
    const stones = gameData?.spiritStones ?? 0;
    if (stones < amount) return res.status(400).json({ error: 'çµçŸ³ä¸è¶³' });
    gameData.spiritStones = stones - amount;
    await pool.query('UPDATE players SET game_data=$1, spirit_stones=$2 WHERE wallet=$3',
      [JSON.stringify(gameData), gameData.spiritStones, req.user.wallet]);
    const contribution = Math.floor(amount / 10);
    await pool.query('UPDATE sect_members SET contribution=contribution+$1 WHERE wallet=$2', [contribution, req.user.wallet]);
    await pool.query('UPDATE sects SET exp=exp+$1 WHERE id=$2', [amount, mem.rows[0].sect_id]);
    await checkSectLevelUp(mem.rows[0].sect_id);
    res.json({ ok: true, contribution, exp: amount });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/sect/members
app.get('/api/sect/members', auth, async (req, res) => {
  try {
    const { sectId } = req.query;
    const id = sectId || (await pool.query('SELECT sect_id FROM sect_members WHERE wallet=$1', [req.user.wallet])).rows[0]?.sect_id;
    if (!id) return res.status(400).json({ error: 'æœªæŒ‡å®šå®—é—¨' });
    const members = await pool.query(
      `SELECT sm.wallet, sm.role, sm.contribution, sm.joined_at, p.name, p.level, p.realm, p.combat_power
       FROM sect_members sm LEFT JOIN players p ON sm.wallet = p.wallet WHERE sm.sect_id=$1 ORDER BY sm.role='leader' DESC, sm.role='elder' DESC, sm.contribution DESC`,
      [id]
    );
    res.json({ members: members.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// === WebSocket ä¸–ç•ŒèŠå¤© + å…¨æœåŠ¨æ€ ===
const server = createServer(app);
const wss = new WebSocketServer({ server, path: '/ws' });

const onlineClients = new Map(); // ws -> { wallet, name }
const recentMessages = []; // æœ€è¿‘50æ¡èŠå¤©
const recentEvents = []; // æœ€è¿‘30æ¡å…¨æœåŠ¨æ€
const MAX_CHAT = 50;
const MAX_EVENTS = 30;
const CHAT_COOLDOWN = 3000; // å‘è¨€å†·å´3ç§’
const lastChatTime = new Map(); // wallet -> timestamp

// === PK ç³»ç»Ÿ ===
const pkChallenges = new Map(); // challengeId -> { from, to, fromStats, timestamp }
const pkCooldown = new Map(); // wallet -> timestamp
const PK_COOLDOWN_MS = 30000; // PK å†·å´ 30ç§’
const PK_REWARD = 500; // èƒœè€…å¥–åŠ±çµçŸ³
let pkIdCounter = 0;

function getWsByWallet(wallet) {
  for (const [ws, info] of onlineClients) {
    if (info.wallet === wallet) return ws;
  }
  return null;
}

function runPkBattle(statsA, statsB) {
  // ç®€åŒ–ç‰ˆæœåŠ¡ç«¯æˆ˜æ–—ï¼ˆå¤ç”¨å‰ç«¯ combat é€»è¾‘ï¼‰
  const calcDmg = (atk, def) => {
    let dmg = atk.attack * (100 / (100 + def.defense));
    let isCrit = Math.random() < (atk.critRate || 0.05);
    let isCombo = Math.random() < (atk.comboRate || 0);
    let isDodged = Math.random() < (def.dodgeRate || 0.05);
    if (isCrit) dmg *= 1.5 + (atk.critDamageBoost || 0);
    if (isCombo) dmg *= 1.3;
    dmg *= 1 - (def.finalDamageReduce || 0);
    return { damage: Math.floor(dmg), isCrit, isCombo, isDodged };
  };

  let hpA = statsA.health, hpB = statsB.health;
  const rounds = [];
  const maxRounds = 15;

  for (let i = 0; i < maxRounds && hpA > 0 && hpB > 0; i++) {
    const r = { round: i + 1, actions: [] };
    // A å…ˆæ”»ï¼ˆé€Ÿåº¦é«˜å…ˆæ‰‹ï¼‰
    const first = (statsA.speed || 10) >= (statsB.speed || 10) ? 'A' : 'B';
    const order = first === 'A' ? [['A', statsA, statsB], ['B', statsB, statsA]] : [['B', statsB, statsA], ['A', statsA, statsB]];

    for (const [side, atk, def] of order) {
      if ((side === 'A' ? hpA : hpB) <= 0) break;
      const hit = calcDmg(atk, def);
      if (hit.isDodged) {
        r.actions.push({ attacker: side, isDodged: true, damage: 0, isCrit: false, isCombo: false });
      } else {
        if (side === 'A') hpB = Math.max(0, hpB - hit.damage);
        else hpA = Math.max(0, hpA - hit.damage);
        r.actions.push({ attacker: side, damage: hit.damage, isCrit: hit.isCrit, isCombo: hit.isCombo, isDodged: false });
      }
      if (hpA <= 0 || hpB <= 0) break;
    }
    r.hpA = Math.max(0, hpA);
    r.hpB = Math.max(0, hpB);
    rounds.push(r);
  }

  const winner = hpA > hpB ? 'A' : hpB > hpA ? 'B' : 'draw';
  return { rounds, winner, finalHpA: Math.max(0, hpA), finalHpB: Math.max(0, hpB) };
}

function broadcast(data) {
  const msg = JSON.stringify(data);
  wss.clients.forEach(c => { if (c.readyState === 1) c.send(msg); });
}

// å…¨æœåŠ¨æ€å¹¿æ’­ï¼ˆä¾› API è°ƒç”¨ï¼‰
function broadcastEvent(text, type = 'info') {
  const evt = { type: 'event', text, eventType: type, time: Date.now() };
  recentEvents.push(evt);
  if (recentEvents.length > MAX_EVENTS) recentEvents.shift();
  broadcast(evt);
}

wss.on('connection', (ws, req) => {
  let userInfo = null;

  // å‘é€å†å²æ¶ˆæ¯å’ŒåŠ¨æ€
  ws.send(JSON.stringify({ type: 'init', messages: recentMessages, events: recentEvents, online: wss.clients.size }));

  ws.on('message', async (raw) => {
    try {
      const data = JSON.parse(raw);

      // å¿ƒè·³
      if (data.type === 'ping') {
        ws.send(JSON.stringify({ type: 'pong' }));
        return;
      }

      // è®¤è¯
      if (data.type === 'auth') {
        try {
          const decoded = jwt.verify(data.token, JWT_SECRET);
          userInfo = { wallet: decoded.wallet, name: data.name || 'æ— åä¿®å£«' };
          onlineClients.set(ws, userInfo);
          broadcast({ type: 'online', count: wss.clients.size });
          broadcastEvent(`${userInfo.name} è¿›å…¥äº†ä¿®ä»™ç•Œ`, 'join');
        } catch { ws.send(JSON.stringify({ type: 'error', msg: 'è®¤è¯å¤±è´¥' })); }
        return;
      }

      // èŠå¤©æ¶ˆæ¯
      if (data.type === 'chat') {
        if (!userInfo) return ws.send(JSON.stringify({ type: 'error', msg: 'è¯·å…ˆç™»å½•' }));
        const text = (data.text || '').trim().slice(0, 200);
        if (!text) return;

        // å†·å´æ£€æŸ¥
        const now = Date.now();
        const last = lastChatTime.get(userInfo.wallet) || 0;
        if (now - last < CHAT_COOLDOWN) {
          return ws.send(JSON.stringify({ type: 'error', msg: 'å‘è¨€å¤ªå¿«ï¼Œè¯·ç¨åå†è¯•' }));
        }
        lastChatTime.set(userInfo.wallet, now);

        const msg = {
          type: 'chat',
          name: userInfo.name,
          wallet: userInfo.wallet.slice(0, 6) + '...' + userInfo.wallet.slice(-4),
          text,
          time: now
        };
        recentMessages.push(msg);
        if (recentMessages.length > MAX_CHAT) recentMessages.shift();
        broadcast(msg);
      }

      // === PK æ¶ˆæ¯å¤„ç† ===
      // æ›´æ–°æˆ˜æ–—æ•°æ®
      if (data.type === 'pk_update_stats') {
        if (!userInfo) return;
        userInfo.stats = data.stats || {};
        userInfo.level = data.level || 1;
        userInfo.realm = data.realm || 'ç»ƒæ°”ä¸€å±‚';
        userInfo.combatPower = data.combatPower || 0;
        onlineClients.set(ws, userInfo);
      }

      // è·å–åœ¨çº¿ç©å®¶åˆ—è¡¨
      if (data.type === 'pk_get_players') {
        if (!userInfo) return;
        const players = [];
        for (const [, info] of onlineClients) {
          if (info.wallet !== userInfo.wallet) {
            players.push({
              wallet: info.wallet.slice(0, 6) + '...' + info.wallet.slice(-4),
              fullWallet: info.wallet,
              name: info.name,
              level: info.level || 1,
              realm: info.realm || 'ç»ƒæ°”ä¸€å±‚',
              combatPower: info.combatPower || 0
            });
          }
        }
        ws.send(JSON.stringify({ type: 'pk_players', players }));
      }

      // å‘èµ·æŒ‘æˆ˜
      if (data.type === 'pk_challenge') {
        if (!userInfo) return;
        const now = Date.now();
        const lastPk = pkCooldown.get(userInfo.wallet) || 0;
        if (now - lastPk < PK_COOLDOWN_MS) {
          return ws.send(JSON.stringify({ type: 'pk_error', msg: `PKå†·å´ä¸­ï¼Œ${Math.ceil((PK_COOLDOWN_MS - (now - lastPk)) / 1000)}ç§’åå†è¯•` }));
        }
        const targetWs = getWsByWallet(data.targetWallet);
        if (!targetWs) return ws.send(JSON.stringify({ type: 'pk_error', msg: 'å¯¹æ–¹å·²ç¦»çº¿' }));

        const challengeId = ++pkIdCounter;
        pkChallenges.set(challengeId, {
          from: userInfo.wallet, to: data.targetWallet,
          fromName: userInfo.name, toName: onlineClients.get(targetWs)?.name || 'æ— åä¿®å£«',
          fromStats: userInfo.stats || {}, timestamp: now
        });
        // 30ç§’åè‡ªåŠ¨è¿‡æœŸ
        setTimeout(() => pkChallenges.delete(challengeId), 30000);

        targetWs.send(JSON.stringify({
          type: 'pk_challenged', challengeId,
          from: userInfo.wallet.slice(0, 6) + '...' + userInfo.wallet.slice(-4),
          fromName: userInfo.name,
          fromLevel: userInfo.level || 1,
          fromCombatPower: userInfo.combatPower || 0
        }));
        ws.send(JSON.stringify({ type: 'pk_challenge_sent', challengeId }));
      }

      // æ¥å—æŒ‘æˆ˜
      if (data.type === 'pk_accept') {
        if (!userInfo) return;
        const challenge = pkChallenges.get(data.challengeId);
        if (!challenge || challenge.to !== userInfo.wallet) {
          return ws.send(JSON.stringify({ type: 'pk_error', msg: 'æŒ‘æˆ˜å·²è¿‡æœŸ' }));
        }
        pkChallenges.delete(data.challengeId);

        const fromWs = getWsByWallet(challenge.from);
        if (!fromWs) return ws.send(JSON.stringify({ type: 'pk_error', msg: 'æŒ‘æˆ˜è€…å·²ç¦»çº¿' }));

        // è®¾ç½®å†·å´
        pkCooldown.set(challenge.from, Date.now());
        pkCooldown.set(userInfo.wallet, Date.now());

        // æ„é€ åŒæ–¹å±æ€§
        const statsA = {
          health: challenge.fromStats.health || 100,
          attack: challenge.fromStats.attack || 10,
          defense: challenge.fromStats.defense || 5,
          speed: challenge.fromStats.speed || 10,
          critRate: challenge.fromStats.critRate || 0.05,
          comboRate: challenge.fromStats.comboRate || 0,
          dodgeRate: challenge.fromStats.dodgeRate || 0.05,
          critDamageBoost: challenge.fromStats.critDamageBoost || 0,
          finalDamageReduce: challenge.fromStats.finalDamageReduce || 0,
        };
        const myStats = userInfo.stats || {};
        const statsB = {
          health: myStats.health || 100,
          attack: myStats.attack || 10,
          defense: myStats.defense || 5,
          speed: myStats.speed || 10,
          critRate: myStats.critRate || 0.05,
          comboRate: myStats.comboRate || 0,
          dodgeRate: myStats.dodgeRate || 0.05,
          critDamageBoost: myStats.critDamageBoost || 0,
          finalDamageReduce: myStats.finalDamageReduce || 0,
        };

        // è·‘æˆ˜æ–—
        const result = runPkBattle(statsA, statsB);
        const winnerWallet = result.winner === 'A' ? challenge.from : result.winner === 'B' ? userInfo.wallet : null;
        const winnerName = result.winner === 'A' ? challenge.fromName : result.winner === 'B' ? userInfo.name : null;

        // å‘æ”¾å¥–åŠ±
        if (winnerWallet) {
          try {
            await pool.query('UPDATE players SET spirit_stones = spirit_stones + $1 WHERE wallet = $2', [PK_REWARD, winnerWallet]);
          } catch {}
          broadcastEvent(`${winnerName} åœ¨åˆ‡ç£‹ä¸­å‡»è´¥äº† ${result.winner === 'A' ? challenge.toName : challenge.fromName}ï¼Œè·å¾— ${PK_REWARD} çµçŸ³ï¼`, 'pk');
        }

        // æŒä¹…åŒ– PK è®°å½•
        try {
          await pool.query(
            `INSERT INTO pk_records (wallet_a, wallet_b, name_a, name_b, winner, winner_wallet, rounds_data, reward)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
            [challenge.from, userInfo.wallet, challenge.fromName, userInfo.name,
             result.winner, winnerWallet, JSON.stringify(result.rounds), winnerWallet ? PK_REWARD : 0]
          );
        } catch {}

        const battleResult = {
          type: 'pk_result',
          nameA: challenge.fromName, nameB: userInfo.name,
          walletA: challenge.from, walletB: userInfo.wallet,
          rounds: result.rounds, winner: result.winner,
          winnerName, reward: PK_REWARD,
          finalHpA: result.finalHpA, finalHpB: result.finalHpB,
          maxHpA: statsA.health, maxHpB: statsB.health
        };

        fromWs.send(JSON.stringify(battleResult));
        ws.send(JSON.stringify(battleResult));
      }

      // æ‹’ç»æŒ‘æˆ˜
      if (data.type === 'pk_decline') {
        const challenge = pkChallenges.get(data.challengeId);
        if (challenge) {
          pkChallenges.delete(data.challengeId);
          const fromWs = getWsByWallet(challenge.from);
          if (fromWs) fromWs.send(JSON.stringify({ type: 'pk_declined', by: userInfo?.name || 'å¯¹æ–¹' }));
        }
      }
    } catch {}
  });

  ws.on('close', () => {
    if (userInfo) {
      onlineClients.delete(ws);
      broadcast({ type: 'online', count: wss.clients.size });
    }
  });
});

// æš´éœ² broadcastEvent ç»™è·¯ç”±ä½¿ç”¨
// === Admin æ´»åŠ¨ç®¡ç† ===
const adminAuth = async (req, res, next) => {
  if (!req.user) return res.status(401).json({ error: "æœªç™»å½•" });
  const adminWallet = "0xfad7eb0814b6838b05191a07fb987957d50c4ca9";
  if (req.user.wallet.toLowerCase() !== adminWallet) return res.status(403).json({ error: "æ— æƒé™" });
  next();
};

// GET /api/admin/events - è·å–æ‰€æœ‰æ´»åŠ¨
app.get("/api/admin/events", auth, adminAuth, async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM events ORDER BY created_at DESC");
    res.json({ events: result.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/admin/events - åˆ›å»ºæ´»åŠ¨
app.post("/api/admin/events", auth, adminAuth, async (req, res) => {
  try {
    const { name, description, type, config, starts_at, ends_at, rewards, active } = req.body;
    if (!name || !type || !starts_at || !ends_at) return res.status(400).json({ error: "ç¼ºå°‘å¿…å¡«å­—æ®µ" });
    const result = await pool.query(
      `INSERT INTO events (name, description, type, config, starts_at, ends_at, rewards, active) VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING *`,
      [name, description || "", type, config || {}, starts_at, ends_at, rewards || [], active !== false]
    );
    res.json({ event: result.rows[0] });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// PUT /api/admin/events/:id - ç¼–è¾‘æ´»åŠ¨
app.put("/api/admin/events/:id", auth, adminAuth, async (req, res) => {
  try {
    const { name, description, type, config, starts_at, ends_at, rewards, active } = req.body;
    const result = await pool.query(
      `UPDATE events SET name=COALESCE($1,name), description=COALESCE($2,description), type=COALESCE($3,type), config=COALESCE($4,config), starts_at=COALESCE($5,starts_at), ends_at=COALESCE($6,ends_at), rewards=COALESCE($7,rewards), active=COALESCE($8,active) WHERE id=$9 RETURNING *`,
      [name, description, type, config, starts_at, ends_at, rewards, active, req.params.id]
    );
    if (!result.rows.length) return res.status(404).json({ error: "æ´»åŠ¨ä¸å­˜åœ¨" });
    res.json({ event: result.rows[0] });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// DELETE /api/admin/events/:id - åˆ é™¤æ´»åŠ¨
app.delete("/api/admin/events/:id", auth, adminAuth, async (req, res) => {
  try {
    await pool.query("DELETE FROM event_claims WHERE event_id=$1", [req.params.id]);
    const result = await pool.query("DELETE FROM events WHERE id=$1 RETURNING id", [req.params.id]);
    if (!result.rows.length) return res.status(404).json({ error: "æ´»åŠ¨ä¸å­˜åœ¨" });
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/admin/events/:id/claims - æŸ¥çœ‹é¢†å–è®°å½•
app.get("/api/admin/events/:id/claims", auth, adminAuth, async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT ec.id, ec.wallet, ec.claimed_at, p.name FROM event_claims ec LEFT JOIN players p ON ec.wallet = p.wallet WHERE ec.event_id=$1 ORDER BY ec.claimed_at DESC`,
      [req.params.id]
    );
    res.json({ claims: result.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/admin/stats - æ´»åŠ¨ç»Ÿè®¡
app.get("/api/admin/stats", auth, adminAuth, async (req, res) => {
  try {
    const activeEvents = await pool.query("SELECT COUNT(*) FROM events WHERE active=TRUE AND starts_at<=NOW() AND ends_at>NOW()");
    const totalClaims = await pool.query("SELECT COUNT(*) FROM event_claims");
    const totalPlayers = await pool.query("SELECT COUNT(*) FROM players");
    res.json({
      activeEvents: parseInt(activeEvents.rows[0].count),
      totalClaims: parseInt(totalClaims.rows[0].count),
      totalPlayers: parseInt(totalPlayers.rows[0].count)
    });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

app.locals.broadcastEvent = broadcastEvent;


// === ä¸–ç•Œ Boss ç³»ç»Ÿ ===
const bossAttackCooldown = new Map(); // wallet -> timestamp

async function settleBossRewards(bossId) {
  try {
    const ranking = await pool.query(
      'SELECT wallet, player_name, damage FROM boss_damage_log WHERE boss_id = $1 ORDER BY damage DESC',
      [bossId]
    );
    const rows = ranking.rows;
    for (let i = 0; i < rows.length; i++) {
      const rank = i + 1;
      let stones = 1000;
      if (rank === 1) stones = 50000;
      else if (rank === 2) stones = 30000;
      else if (rank === 3) stones = 20000;
      else if (rank <= 10) stones = 10000;
      else if (rank <= 50) stones = 5000;
      await pool.query(
        'INSERT INTO boss_rewards (boss_id, wallet, rank, reward_stones) VALUES ($1, $2, $3, $4)',
        [bossId, rows[i].wallet, rank, stones]
      );
    }
    const boss = await pool.query('SELECT name FROM world_bosses WHERE id = $1', [bossId]);
    const topDamagers = rows.slice(0, 5).map((r, i) => ({
      rank: i + 1, name: r.player_name, damage: Number(r.damage)
    }));
    const killerName = rows.length > 0 ? rows[0].player_name : 'æ— åä¿®å£«';
    broadcast({ type: 'boss_dead', data: { bossName: boss.rows[0]?.name, killerName, topDamagers } });
    broadcastEvent(`ğŸ‰ ä¸–ç•ŒBoss ${boss.rows[0]?.name} å·²è¢«å‡»æ€ï¼æœ€å¤§åŠŸè‡£: ${killerName}`, 'boss');
  } catch (e) {
    console.error('Boss reward settlement error:', e);
  }
}

// GET /api/boss/current
app.get('/api/boss/current', auth, async (req, res) => {
  try {
    const boss = await pool.query(
      "SELECT * FROM world_bosses WHERE status = 'active' ORDER BY spawn_time DESC LIMIT 1"
    );
    if (boss.rows.length === 0) return res.json({ boss: null });
    const b = boss.rows[0];
    const myDmg = await pool.query(
      'SELECT damage, attacks_count FROM boss_damage_log WHERE boss_id = $1 AND wallet = $2',
      [b.id, req.user.wallet]
    );
    const myRank = await pool.query(
      'SELECT COUNT(*) + 1 as rank FROM boss_damage_log WHERE boss_id = $1 AND damage > COALESCE((SELECT damage FROM boss_damage_log WHERE boss_id = $1 AND wallet = $2), 0)',
      [b.id, req.user.wallet]
    );
    const totalPlayers = await pool.query(
      'SELECT COUNT(*) FROM boss_damage_log WHERE boss_id = $1', [b.id]
    );
    res.json({
      boss: {
        id: b.id, name: b.name, level: b.level,
        maxHp: Number(b.max_hp), currentHp: Number(b.current_hp),
        attack: b.attack, defense: b.defense,
        description: b.description, status: b.status,
        rewardsConfig: b.rewards_config, spawnTime: b.spawn_time
      },
      myDamage: myDmg.rows[0] ? Number(myDmg.rows[0].damage) : 0,
      myAttacks: myDmg.rows[0] ? myDmg.rows[0].attacks_count : 0,
      myRank: myDmg.rows[0] ? parseInt(myRank.rows[0].rank) : 0,
      totalPlayers: parseInt(totalPlayers.rows[0].count)
    });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/boss/attack
app.post('/api/boss/attack', auth, async (req, res) => {
  try {
    const wallet = req.user.wallet;
    const now = Date.now();
    const lastAtk = bossAttackCooldown.get(wallet) || 0;
    if (now - lastAtk < 3000) {
      return res.status(400).json({ error: `å†·å´ä¸­ï¼Œ${Math.ceil((3000 - (now - lastAtk)) / 1000)}ç§’åå†è¯•` });
    }
    const boss = await pool.query(
      "SELECT * FROM world_bosses WHERE status = 'active' ORDER BY spawn_time DESC LIMIT 1"
    );
    if (boss.rows.length === 0) return res.status(400).json({ error: 'å½“å‰æ²¡æœ‰ä¸–ç•ŒBoss' });
    const b = boss.rows[0];
    if (Number(b.current_hp) <= 0) return res.status(400).json({ error: 'Bosså·²è¢«å‡»æ€' });
    const player = await pool.query('SELECT * FROM players WHERE wallet = $1', [wallet]);
    if (!player.rows.length) return res.status(400).json({ error: 'ç©å®¶ä¸å­˜åœ¨' });
    const p = player.rows[0];
    const gameData = typeof p.game_data === 'string' ? JSON.parse(p.game_data) : (p.game_data || {});
    const spirit = gameData.spirit || 0;
    if (spirit < 10) return res.status(400).json({ error: 'çµåŠ›ä¸è¶³ï¼Œéœ€è¦10çµåŠ›' });
    gameData.spirit = spirit - 10;
    await pool.query('UPDATE players SET game_data = $1 WHERE wallet = $2', [JSON.stringify(gameData), wallet]);
    const pAtk = gameData.baseAttributes?.attack || p.combat_power || 100;
    const critRate = gameData.combatAttributes?.critRate || 0.05;
    const isCrit = Math.random() < critRate;
    let damage = Math.max(1, Math.floor(pAtk * (100 / (100 + b.defense)) * (0.9 + Math.random() * 0.2)));
    if (isCrit) damage = Math.floor(damage * 1.5);
    const newHp = Math.max(0, Number(b.current_hp) - damage);
    await pool.query('UPDATE world_bosses SET current_hp = $1 WHERE id = $2', [newHp, b.id]);
    await pool.query(
      `INSERT INTO boss_damage_log (boss_id, wallet, player_name, damage, attacks_count, last_attack_at)
       VALUES ($1, $2, $3, $4, 1, NOW())
       ON CONFLICT (boss_id, wallet) DO UPDATE SET
         damage = boss_damage_log.damage + $4,
         attacks_count = boss_damage_log.attacks_count + 1,
         player_name = $3,
         last_attack_at = NOW()`,
      [b.id, wallet, p.name || 'æ— åä¿®å£«', damage]
    );
    bossAttackCooldown.set(wallet, now);
    const myTotal = await pool.query(
      'SELECT damage FROM boss_damage_log WHERE boss_id = $1 AND wallet = $2', [b.id, wallet]
    );
    broadcast({
      type: 'boss_hit',
      data: {
        playerName: p.name || 'æ— åä¿®å£«',
        damage, isCrit,
        bossHp: newHp, bossMaxHp: Number(b.max_hp)
      }
    });
    if (newHp <= 0) {
      await pool.query("UPDATE world_bosses SET status = 'dead', death_time = NOW() WHERE id = $1", [b.id]);
      await settleBossRewards(b.id);
    }
    res.json({
      damage, isCrit,
      bossHp: newHp, bossMaxHp: Number(b.max_hp),
      myTotalDamage: Number(myTotal.rows[0]?.damage || damage),
      spirit: gameData.spirit
    });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/boss/ranking
app.get('/api/boss/ranking', auth, async (req, res) => {
  try {
    const boss = await pool.query(
      "SELECT id FROM world_bosses WHERE status = 'active' ORDER BY spawn_time DESC LIMIT 1"
    );
    if (boss.rows.length === 0) return res.json({ ranking: [] });
    const bossId = boss.rows[0].id;
    const result = await pool.query(
      'SELECT wallet, player_name, damage, attacks_count FROM boss_damage_log WHERE boss_id = $1 ORDER BY damage DESC LIMIT 50', [bossId]
    );
    const ranking = result.rows.map((r, i) => ({
      rank: i + 1,
      name: r.player_name,
      wallet: r.wallet.slice(0, 6) + '...' + r.wallet.slice(-4),
      fullWallet: r.wallet,
      damage: Number(r.damage),
      attacks: r.attacks_count
    }));
    res.json({ ranking });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/boss/rewards
app.get('/api/boss/rewards', auth, async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT br.*, wb.name as boss_name FROM boss_rewards br
       LEFT JOIN world_bosses wb ON br.boss_id = wb.id
       WHERE br.wallet = $1 ORDER BY br.created_at DESC`, [req.user.wallet]
    );
    res.json({ rewards: result.rows.map(r => ({
      id: r.id, bossId: r.boss_id, bossName: r.boss_name,
      rank: r.rank, stones: r.reward_stones, items: r.reward_items,
      claimed: r.claimed, createdAt: r.created_at
    })) });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/boss/rewards/claim
app.post('/api/boss/rewards/claim', auth, async (req, res) => {
  try {
    const unclaimed = await pool.query(
      'SELECT * FROM boss_rewards WHERE wallet = $1 AND claimed = FALSE', [req.user.wallet]
    );
    if (unclaimed.rows.length === 0) return res.status(400).json({ error: 'æ²¡æœ‰å¯é¢†å–çš„å¥–åŠ±' });
    let totalStones = 0;
    for (const r of unclaimed.rows) {
      totalStones += r.reward_stones;
      await pool.query('UPDATE boss_rewards SET claimed = TRUE WHERE id = $1', [r.id]);
    }
    const player = await pool.query('SELECT game_data FROM players WHERE wallet = $1', [req.user.wallet]);
    const gameData = typeof player.rows[0].game_data === 'string' ? JSON.parse(player.rows[0].game_data) : (player.rows[0].game_data || {});
    gameData.spiritStones = (gameData.spiritStones || 0) + totalStones;
    await pool.query('UPDATE players SET game_data = $1, spirit_stones = $2 WHERE wallet = $3',
      [JSON.stringify(gameData), gameData.spiritStones, req.user.wallet]);
    res.json({ ok: true, totalStones, newSpiritStones: gameData.spiritStones });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/boss/history
app.get('/api/boss/history', auth, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, name, level, max_hp, attack, defense, status, spawn_time, death_time FROM world_bosses ORDER BY created_at DESC LIMIT 20'
    );
    res.json({ bosses: result.rows.map(r => ({
      id: r.id, name: r.name, level: r.level, maxHp: Number(r.max_hp),
      attack: r.attack, defense: r.defense, status: r.status,
      spawnTime: r.spawn_time, deathTime: r.death_time
    })) });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/admin/boss/spawn
app.post('/api/admin/boss/spawn', auth, adminAuth, async (req, res) => {
  try {
    const { name, level, max_hp, attack, defense, description, rewards_config } = req.body;
    if (!name || !max_hp) return res.status(400).json({ error: 'ç¼ºå°‘å¿…å¡«å­—æ®µ' });
    await pool.query("UPDATE world_bosses SET status = 'dead', death_time = NOW() WHERE status = 'active'");
    const result = await pool.query(
      `INSERT INTO world_bosses (name, level, max_hp, current_hp, attack, defense, description, rewards_config, status, spawn_time)
       VALUES ($1,$2,$3,$3,$4,$5,$6,$7,'active',NOW()) RETURNING *`,
      [name, level || 100, max_hp, attack || 5000, defense || 2000, description || '', JSON.stringify(rewards_config || {})]
    );
    const b = result.rows[0];
    broadcast({ type: 'boss_spawn', data: { bossName: b.name, level: b.level, maxHp: Number(b.max_hp) } });
    broadcastEvent(`ğŸ‰ ä¸–ç•ŒBossã€${b.name}ã€‘é™ä¸´äº†ï¼å…¨ä½“ä¿®å£«å‡†å¤‡è®¨ä¼ï¼`, 'boss');
    res.json({ ok: true, boss: b });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/admin/boss/list
app.get('/api/admin/boss/list', auth, adminAuth, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM world_bosses ORDER BY created_at DESC');
    res.json({ bosses: result.rows });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/accept - æ¥å—å¥½å‹ç”³è¯·
app.post("/api/friend/accept", auth, async (req, res) => {
  try {
    const { friendship_id } = req.body;
    if (!friendship_id) return res.status(400).json({ error: "ç¼ºå°‘å‚æ•°" });
    const f = await pool.query(`SELECT * FROM friendships WHERE id=$1 AND to_wallet=$2 AND status=$3`, [friendship_id, req.user.wallet, "pending"]);
    if (!f.rows.length) return res.status(404).json({ error: "ç”³è¯·ä¸å­˜åœ¨" });
    const countRes = await pool.query(`SELECT COUNT(*) FROM friendships WHERE (from_wallet=$1 OR to_wallet=$1) AND status=$2`, [req.user.wallet, "accepted"]);
    if (parseInt(countRes.rows[0].count) >= 50) return res.status(400).json({ error: "å¥½å‹æ•°é‡å·²è¾¾ä¸Šé™(50)" });
    await pool.query(`UPDATE friendships SET status=$1, updated_at=NOW() WHERE id=$2`, ["accepted", friendship_id]);
    res.json({ ok: true, message: "å·²æ¥å—å¥½å‹ç”³è¯·" });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/reject - æ‹’ç»å¥½å‹ç”³è¯·
app.post("/api/friend/reject", auth, async (req, res) => {
  try {
    const { friendship_id } = req.body;
    if (!friendship_id) return res.status(400).json({ error: "ç¼ºå°‘å‚æ•°" });
    const f = await pool.query(`SELECT * FROM friendships WHERE id=$1 AND to_wallet=$2 AND status=$3`, [friendship_id, req.user.wallet, "pending"]);
    if (!f.rows.length) return res.status(404).json({ error: "ç”³è¯·ä¸å­˜åœ¨" });
    await pool.query(`UPDATE friendships SET status=$1, updated_at=NOW() WHERE id=$2`, ["rejected", friendship_id]);
    res.json({ ok: true, message: "å·²æ‹’ç»å¥½å‹ç”³è¯·" });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/remove - åˆ é™¤å¥½å‹
app.post("/api/friend/remove", auth, async (req, res) => {
  try {
    const { wallet } = req.body;
    if (!wallet) return res.status(400).json({ error: "ç¼ºå°‘å‚æ•°" });
    const result = await pool.query(
      `DELETE FROM friendships WHERE ((from_wallet=$1 AND to_wallet=$2) OR (from_wallet=$2 AND to_wallet=$1)) AND status=$3`,
      [req.user.wallet, wallet, "accepted"]
    );
    if (result.rowCount === 0) return res.status(404).json({ error: "å¥½å‹å…³ç³»ä¸å­˜åœ¨" });
    res.json({ ok: true, message: "å·²åˆ é™¤å¥½å‹" });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/friend/profile/:wallet - å¥½å‹è¯¦æƒ…
app.get("/api/friend/profile/:wallet", auth, async (req, res) => {
  try {
    const w = req.user.wallet;
    const tw = req.params.wallet;
    const isFriend = await pool.query(
      `SELECT id FROM friendships WHERE ((from_wallet=$1 AND to_wallet=$2) OR (from_wallet=$2 AND to_wallet=$1)) AND status=$3`,
      [w, tw, "accepted"]
    );
    if (!isFriend.rows.length) return res.status(403).json({ error: "ä¸æ˜¯å¥½å‹å…³ç³»" });
    const p = await pool.query(`SELECT wallet, name, level, realm, combat_power, game_data, vip_level FROM players WHERE wallet=$1`, [tw]);
    if (!p.rows.length) return res.status(404).json({ error: "ç©å®¶ä¸å­˜åœ¨" });
    const player = p.rows[0];
    const gd = typeof player.game_data === "string" ? JSON.parse(player.game_data) : (player.game_data || {});
    const equippedArtifacts = gd.equippedArtifacts || {};
    const sect = await pool.query(
      `SELECT s.name as sect_name, sm.role FROM sect_members sm JOIN sects s ON s.id=sm.sect_id WHERE sm.wallet=$1`, [tw]
    );
    res.json({ ok: true, profile: {
      wallet: player.wallet, name: player.name || "æ— åä¿®å£«", level: player.level || 1,
      realm: player.realm || "ç»ƒæ°”æœŸä¸€å±‚", combatPower: Number(player.combat_power || 0),
      vipLevel: player.vip_level || 0, equippedArtifacts,
      sect: sect.rows.length ? { name: sect.rows[0].sect_name, role: sect.rows[0].role } : null
    }});
  } catch (e) { res.status(500).json({ error: e.message }); }
});
// POST /api/friend/gift - é€ç¤¼
app.post("/api/friend/gift", auth, async (req, res) => {
  try {
    const { to_wallet, gift_type, gift_value, message: msg } = req.body;
    const w = req.user.wallet;
    if (!to_wallet || !gift_type || !gift_value) return res.status(400).json({ error: "ç¼ºå°‘å‚æ•°" });
    if (gift_value <= 0 || gift_value > 100000) return res.status(400).json({ error: "ç¤¼ç‰©æ•°é‡æ— æ•ˆ(1-100000)" });
    const isFriend = await pool.query(
      `SELECT id FROM friendships WHERE ((from_wallet=$1 AND to_wallet=$2) OR (from_wallet=$2 AND to_wallet=$1)) AND status=$3`,
      [w, to_wallet, "accepted"]
    );
    if (!isFriend.rows.length) return res.status(403).json({ error: "ä¸æ˜¯å¥½å‹å…³ç³»" });
    const todayStart = new Date(); todayStart.setHours(0,0,0,0);
    const giftCount = await pool.query(
      `SELECT COUNT(*) FROM friend_gifts WHERE from_wallet=$1 AND created_at >= $2`, [w, todayStart]
    );
    if (parseInt(giftCount.rows[0].count) >= 3) return res.status(400).json({ error: "ä»Šæ—¥é€ç¤¼æ¬¡æ•°å·²ç”¨å®Œ(3/3)" });
    if (gift_type === "spirit_stones") {
      const player = await pool.query(`SELECT spirit_stones, game_data FROM players WHERE wallet=$1`, [w]);
      if (!player.rows.length) return res.status(404).json({ error: "ç©å®¶ä¸å­˜åœ¨" });
      const gd = typeof player.rows[0].game_data === "string" ? JSON.parse(player.rows[0].game_data) : (player.rows[0].game_data || {});
      const stones = gd.spiritStones ?? player.rows[0].spirit_stones ?? 0;
      if (stones < gift_value) return res.status(400).json({ error: "çµçŸ³ä¸è¶³" });
      gd.spiritStones = (gd.spiritStones || 0) - gift_value;
      await pool.query(`UPDATE players SET game_data=$1, spirit_stones=$2 WHERE wallet=$3`,
        [JSON.stringify(gd), gd.spiritStones, w]);
    }
    await pool.query(
      `INSERT INTO friend_gifts (from_wallet, to_wallet, gift_type, gift_value, message) VALUES ($1,$2,$3,$4,$5)`,
      [w, to_wallet, gift_type, gift_value, msg || ""]
    );
    const remaining = 3 - parseInt(giftCount.rows[0].count) - 1;
    res.json({ ok: true, message: "ç¤¼ç‰©å·²é€å‡º", remaining });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/friend/gifts - æ”¶åˆ°çš„ç¤¼ç‰©åˆ—è¡¨
app.get("/api/friend/gifts", auth, async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT g.id, g.from_wallet, g.gift_type, g.gift_value, g.message, g.claimed, g.created_at, p.name
       FROM friend_gifts g JOIN players p ON p.wallet=g.from_wallet
       WHERE g.to_wallet=$1 ORDER BY g.claimed ASC, g.created_at DESC LIMIT 50`,
      [req.user.wallet]
    );
    res.json({ ok: true, gifts: result.rows.map(r => ({
      id: r.id, fromWallet: r.from_wallet, fromName: r.name || "æ— åä¿®å£«",
      giftType: r.gift_type, giftValue: r.gift_value, message: r.message,
      claimed: r.claimed, createdAt: r.created_at
    })) });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/gifts/:id/claim - é¢†å–ç¤¼ç‰©
app.post("/api/friend/gifts/:id/claim", auth, async (req, res) => {
  try {
    const giftId = req.params.id;
    const g = await pool.query(`SELECT * FROM friend_gifts WHERE id=$1 AND to_wallet=$2 AND claimed=FALSE`, [giftId, req.user.wallet]);
    if (!g.rows.length) return res.status(404).json({ error: "ç¤¼ç‰©ä¸å­˜åœ¨æˆ–å·²é¢†å–" });
    const gift = g.rows[0];
    if (gift.gift_type === "spirit_stones") {
      const player = await pool.query(`SELECT game_data FROM players WHERE wallet=$1`, [req.user.wallet]);
      const gd = typeof player.rows[0].game_data === "string" ? JSON.parse(player.rows[0].game_data) : (player.rows[0].game_data || {});
      gd.spiritStones = (gd.spiritStones || 0) + gift.gift_value;
      await pool.query(`UPDATE players SET game_data=$1, spirit_stones=$2 WHERE wallet=$3`,
        [JSON.stringify(gd), gd.spiritStones, req.user.wallet]);
    }
    await pool.query(`UPDATE friend_gifts SET claimed=TRUE WHERE id=$1`, [giftId]);
    res.json({ ok: true, message: "ç¤¼ç‰©å·²é¢†å–", giftType: gift.gift_type, giftValue: gift.gift_value });
  } catch (e) { res.status(500).json({ error: e.message }); }
});
// ============ å¥½å‹ç³»ç»Ÿ API ============

// GET /api/friend/list - å¥½å‹åˆ—è¡¨
app.get("/api/friend/list", auth, async (req, res) => {
  try {
    const w = req.user.wallet;
    const result = await pool.query(
      `SELECT f.id as friendship_id, 
        CASE WHEN f.from_wallet=$1 THEN f.to_wallet ELSE f.from_wallet END as friend_wallet,
        p.name, p.level, p.realm, p.combat_power, p.updated_at
       FROM friendships f
       JOIN players p ON p.wallet = CASE WHEN f.from_wallet=$1 THEN f.to_wallet ELSE f.from_wallet END
       WHERE (f.from_wallet=$1 OR f.to_wallet=$1) AND f.status=$2
       ORDER BY p.combat_power DESC`,
      [w, "accepted"]
    );
    const now = Date.now();
    const friends = result.rows.map(r => ({
      friendshipId: r.friendship_id,
      wallet: r.friend_wallet,
      name: r.name || "æ— åä¿®å£«",
      level: r.level || 1,
      realm: r.realm || "ç»ƒæ°”æœŸä¸€å±‚",
      combatPower: Number(r.combat_power || 0),
      online: r.updated_at ? (now - new Date(r.updated_at).getTime() < 5 * 60 * 1000) : false
    }));
    res.json({ ok: true, friends, count: friends.length, max: 50 });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// GET /api/friend/requests - æ”¶åˆ°çš„å¥½å‹ç”³è¯·
app.get("/api/friend/requests", auth, async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT f.id, f.from_wallet, f.created_at, p.name, p.level, p.realm, p.combat_power
       FROM friendships f JOIN players p ON p.wallet=f.from_wallet
       WHERE f.to_wallet=$1 AND f.status=$2 ORDER BY f.created_at DESC`,
      [req.user.wallet, "pending"]
    );
    res.json({ ok: true, requests: result.rows.map(r => ({
      id: r.id, wallet: r.from_wallet, name: r.name || "æ— åä¿®å£«",
      level: r.level || 1, realm: r.realm || "ç»ƒæ°”æœŸä¸€å±‚",
      combatPower: Number(r.combat_power || 0), createdAt: r.created_at
    })) });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/search - æœç´¢ç©å®¶
app.post("/api/friend/search", auth, async (req, res) => {
  try {
    const { keyword } = req.body;
    if (!keyword || keyword.trim().length < 1) return res.status(400).json({ error: "è¯·è¾“å…¥æœç´¢å…³é”®è¯" });
    const result = await pool.query(
      `SELECT wallet, name, level, realm, combat_power FROM players
       WHERE name ILIKE $1 AND wallet != $2 LIMIT 20`,
      ["%" + keyword.trim() + "%", req.user.wallet]
    );
    const friendsRes = await pool.query(
      `SELECT CASE WHEN from_wallet=$1 THEN to_wallet ELSE from_wallet END as fw
       FROM friendships WHERE (from_wallet=$1 OR to_wallet=$1) AND status IN ($2,$3)`,
      [req.user.wallet, "accepted", "pending"]
    );
    const friendSet = new Set(friendsRes.rows.map(r => r.fw));
    res.json({ ok: true, players: result.rows.map(r => ({
      wallet: r.wallet, name: r.name || "æ— åä¿®å£«", level: r.level || 1,
      realm: r.realm || "ç»ƒæ°”æœŸä¸€å±‚", combatPower: Number(r.combat_power || 0),
      isFriend: friendSet.has(r.wallet)
    })) });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// POST /api/friend/add - å‘é€å¥½å‹ç”³è¯·
app.post("/api/friend/add", auth, async (req, res) => {
  try {
    const { to_wallet } = req.body;
    const w = req.user.wallet;
    if (!to_wallet) return res.status(400).json({ error: "ç¼ºå°‘å‚æ•°" });
    if (to_wallet.toLowerCase() === w.toLowerCase()) return res.status(400).json({ error: "ä¸èƒ½æ·»åŠ è‡ªå·±" });
    const countRes = await pool.query(
      `SELECT COUNT(*) FROM friendships WHERE (from_wallet=$1 OR to_wallet=$1) AND status=$2`,
      [w, "accepted"]
    );
    if (parseInt(countRes.rows[0].count) >= 50) return res.status(400).json({ error: "å¥½å‹æ•°é‡å·²è¾¾ä¸Šé™(50)" });
    const existing = await pool.query(
      `SELECT id, status FROM friendships WHERE
       ((from_wallet=$1 AND to_wallet=$2) OR (from_wallet=$2 AND to_wallet=$1))`,
      [w, to_wallet]
    );
    if (existing.rows.length > 0) {
      const s = existing.rows[0].status;
      if (s === "accepted") return res.status(400).json({ error: "å·²ç»æ˜¯å¥½å‹äº†" });
      if (s === "pending") return res.status(400).json({ error: "å·²å‘é€è¿‡ç”³è¯·ï¼Œè¯·ç­‰å¾…å¯¹æ–¹å¤„ç†" });
      if (s === "rejected") {
        await pool.query(`UPDATE friendships SET status=$1, from_wallet=$2, to_wallet=$3, updated_at=NOW() WHERE id=$4`,
          ["pending", w, to_wallet, existing.rows[0].id]);
        return res.json({ ok: true, message: "å¥½å‹ç”³è¯·å·²å‘é€" });
      }
    }
    await pool.query(`INSERT INTO friendships (from_wallet, to_wallet, status) VALUES ($1,$2,$3)`, [w, to_wallet, "pending"]);
    res.json({ ok: true, message: "å¥½å‹ç”³è¯·å·²å‘é€" });
  } catch (e) { res.status(500).json({ error: e.message }); }
});
server.listen(PORT, () => console.log(`ä¿®ä»™åç«¯å¯åŠ¨ port ${PORT}`));
